@model DecisionSpark.ViewModels.Question.QuestionViewModel

<div class="question-container multi-select-question" data-question-id="@Model.Id">
    <div class="question-prompt">
        <p>@Model.Prompt</p>
        @if (Model.RetryAttempt.HasValue && Model.RetryAttempt > 0)
        {
            <div class="alert alert-warning" role="alert">
                <strong>Let me try again.</strong> Please select one or more options below.
            </div>
        }
    </div>

    <div class="question-options" role="group" aria-label="@Model.Prompt">
        <div class="selection-count mb-2">
            <span class="badge bg-info">
                <span id="selection-count-@Model.Id">0</span> selected
            </span>
        </div>
        
        @for (int i = 0; i < Model.Options.Count; i++)
        {
            var option = Model.Options[i];
            <div class="form-check option-item @(option.IsNegative ? "negative-option" : "")">
                <input 
                    type="checkbox" 
                    id="option-@Model.Id-@i" 
                    name="selected_option_ids" 
                    value="@option.Id"
                    class="form-check-input multi-select-checkbox"
                    checked="@(option.IsSelected ? "checked" : null)"
                    aria-label="@option.Label"
                    data-is-negative="@option.IsNegative.ToString().ToLower()"
                    data-question-id="@Model.Id"
                />
                <label class="form-check-label" for="option-@Model.Id-@i">
                    @if (option.IsTruncated)
                    {
                        <span title="@option.Label">@option.DisplayLabel</span>
                    }
                    else
                    {
                        @option.DisplayLabel
                    }
                    @if (option.IsNegative)
                    {
                        <span class="badge bg-warning text-dark ms-2" aria-label="Exclusive option">
                            <i class="bi bi-exclamation-circle"></i> Clears other selections
                        </span>
                    }
                </label>
            </div>
        }
    </div>

    @if (Model.ShowCustomInput)
    {
        <div class="custom-input-toggle mt-3">
            <a href="#" class="toggle-custom-text" aria-expanded="false" aria-controls="custom-text-@Model.Id">
                <i class="bi bi-pencil"></i> Type my own answer
            </a>
            <div id="custom-text-@Model.Id" class="custom-text-input mt-2" style="display: none;">
                <input 
                    type="text" 
                    name="user_input" 
                    class="form-control" 
                    placeholder="Type your own answer..."
                    aria-label="Custom text input"
                />
                <small class="form-text text-muted">
                    Note: Custom text will be ignored if you've selected options above.
                </small>
            </div>
        </div>
    }

    <button 
        type="submit" 
        class="btn btn-primary mt-3"
        aria-label="Submit answer">
        Continue
    </button>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const questionId = '@Model.Id';
    
    // Handle negative option enforcement
    const checkboxes = document.querySelectorAll(`input[data-question-id="${questionId}"].multi-select-checkbox`);
    const countSpan = document.getElementById(`selection-count-${questionId}`);
    
    function updateSelectionCount() {
        const checked = Array.from(checkboxes).filter(cb => cb.checked);
        if (countSpan) {
            countSpan.textContent = checked.length;
        }
    }
    
    checkboxes.forEach(checkbox => {
        checkbox.addEventListener('change', function() {
            const isNegative = this.getAttribute('data-is-negative') === 'true';
            
            if (isNegative && this.checked) {
                // Uncheck all other options
                checkboxes.forEach(cb => {
                    if (cb !== this) {
                        cb.checked = false;
                    }
                });
            } else if (!isNegative && this.checked) {
                // Uncheck any negative options
                checkboxes.forEach(cb => {
                    if (cb.getAttribute('data-is-negative') === 'true') {
                        cb.checked = false;
                    }
                });
            }
            
            updateSelectionCount();
        });
    });
    
    // Initialize count
    updateSelectionCount();
    
    // Toggle custom text input
    const toggle = document.querySelector('.toggle-custom-text');
    if (toggle) {
        toggle.addEventListener('click', function(e) {
            e.preventDefault();
            const target = document.getElementById(this.getAttribute('aria-controls'));
            const isExpanded = this.getAttribute('aria-expanded') === 'true';
            this.setAttribute('aria-expanded', !isExpanded);
            target.style.display = isExpanded ? 'none' : 'block';
        });
    }
});
</script>
